// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

import "Windows.Foundation.idl";
import "dualapipartitionattribute.idl";

#include <sdkddkver.h>

#ifdef BUILD_INBOX
import "Windows.AI.MachineLearning.idl";
#define ROOT_NS Windows
#define INBOX_ONLY(x) x
#define OTB_ONLY(x)
#else
import "Microsoft.AI.MachineLearning.idl";
#define INBOX_ONLY(x)
#define OTB_ONLY(x) x
#endif

#ifndef ROOT_NS
#define ROOT_NS Microsoft
#endif

namespace ROOT_NS.AI.MachineLearning.Experimental {
  runtimeclass LearningModelBuilder;

  [marshaling_behavior(agile)]
  [dualapipartition(1)]
  runtimeclass LearningModelSessionOptionsExperimental {
    Windows.Foundation.Collections.IMapView<String, UINT32> GetNamedDimensionOverrides();
  }

  [threading(both)]
  [marshaling_behavior(agile)]
  [dualapipartition(1)]
  runtimeclass LearningModelSessionExperimental {
    LearningModelSessionExperimental(ROOT_NS.AI.MachineLearning.LearningModelSession session);
    LearningModelSessionOptionsExperimental Options { get; };
  }

  [threading(both)]
  [marshaling_behavior(agile)]
  [dualapipartition(1)]
  runtimeclass LearningModelOperator {
    LearningModelOperator(String type);
    LearningModelOperator(String type, String domain);

    LearningModelOperator SetName(String name);
    LearningModelOperator SetInput(String operator_input_name, String input_name);
    LearningModelOperator SetConstant(String operator_input_name, IInspectable default_value);
    LearningModelOperator SetOutput(String operator_output_name, String output_name);
    LearningModelOperator SetAttribute(String name, IInspectable value);

    String Name { get; };
    String Type { get; };
    String Domain { get; };
  }

  [marshaling_behavior(agile)]
  [dualapipartition(1)]
  runtimeclass LearningModelOperatorSet {
    LearningModelBuilder Add(LearningModelOperator op);
  }

  [marshaling_behavior(agile)]
  [dualapipartition(1)]
  runtimeclass LearningModelInputs {
    LearningModelBuilder Add(ROOT_NS.AI.MachineLearning.ILearningModelFeatureDescriptor input);
    LearningModelBuilder Add(String input_name, String input_description, IInspectable default_value);
    LearningModelBuilder AddConstant(String input_name, IInspectable value);
  }

  [marshaling_behavior(agile)]
  [dualapipartition(1)]
  runtimeclass LearningModelOutputs {
    LearningModelBuilder Add(ROOT_NS.AI.MachineLearning.ILearningModelFeatureDescriptor output);
  }

  //! \interface LearningModelBuilder
  //! \brief Represents a trained machine learning model.
  //! \details This is the main object you use to interact with Windows Machine Learning.  You use
  //! it to load, bind, and evaluate trained ONNX models.   To load the model you use
  //! one of the Load constructors.  You can then enumerate the InputFeatures and
  //! OutputFeatures.   To bind and evaluate you create a LearningModelSession.
  [threading(both)]
  [marshaling_behavior(agile)]
  [dualapipartition(1)]
  runtimeclass LearningModelBuilder {
    LearningModelInputs Inputs { get; };
    LearningModelOutputs Outputs { get; };
    LearningModelOperatorSet Operators { get; };

    //! Create a builder.
    static LearningModelBuilder Create(Int32 opset);

    //! Creates a TensorFeatureDescriptor.. this should be a constructor on the TFD
    //TensorFeatureDescriptor(String name, String description, TensorKind kind, Int64[] shape);
    static ROOT_NS.AI.MachineLearning.TensorFeatureDescriptor CreateTensorFeatureDescriptor(String name, String description, ROOT_NS.AI.MachineLearning.TensorKind kind, Int64[] shape);
    static ROOT_NS.AI.MachineLearning.TensorFeatureDescriptor CreateTensorFeatureDescriptor(String name, ROOT_NS.AI.MachineLearning.TensorKind kind, Int64[] shape);

    ROOT_NS.AI.MachineLearning.LearningModel CreateModel();

    void Save(String file_name);
  }

  enum LearningModelOptimizationMode
  {
      OptimizeForRuntimePerformance = 0,
  };

  enum LearningModelBindingStrategy {
    CreateWithZeroCopyITensorNative = 0,
    CreateWithZeroCopyIMemoryBuffer,
    CreateFromShapeIterableAndDataArray,
    CreateFromShapeIterableAndDataIterable,
    CreateFromShapeIterableAndDataIterableRaw,
    CreateFromShapeIterableAndDataIterableRawView,
    CreateFromShapeArrayAndDataArray,
    CreateFromShapeArrayAndDataBuffer,
    CreateFromD3D12Resource
  };

  enum LearningModelReadMode {
    GetAsVectorView = 0,
    GetFromNativeBufferAccess,
    GetFromMemoryBufferReferenceAccess,
    GetAsD3D12Resource
  };

  enum LearningModelPhase {
    LoadModel = 0,
    CreateSession,
    BindInputs,
    BindOutputs,
    Evaluate,
    FetchResults
  };

  enum LearningModelBindMode {
    Bound = 0,
    Unbound
  };

  //! \class LearningModelBindingStrategyFilter
  //! \brief
  [marshaling_behavior(agile)]
  [dualapipartition(1)]
  runtimeclass LearningModelBindingStrategyFilter : Windows.Foundation.Collections.IVectorView<LearningModelBindingStrategy> {
    LearningModelBindingStrategyFilter IncludeAll();
    LearningModelBindingStrategyFilter Include(LearningModelBindingStrategy strategy);
    LearningModelBindingStrategyFilter Clear();
  }

  //! \class LearningModelBindingStrategyFilter
  //! \brief 
  [marshaling_behavior(agile)]
  [dualapipartition(1)]
  runtimeclass LearningModelReadModeFilter : Windows.Foundation.Collections.IVectorView<LearningModelReadMode> {
    LearningModelReadModeFilter IncludeAll();
    LearningModelReadModeFilter Include(LearningModelReadMode mode);
    LearningModelReadModeFilter Clear();
  }

  //! \class LearningModelBindingStrategyFilter
  //! \brief 
  [marshaling_behavior(agile)]
  [dualapipartition(1)]
  runtimeclass LearningModelBindModeFilter : Windows.Foundation.Collections.IVectorView<LearningModelBindMode> {
    LearningModelBindModeFilter IncludeAll();
    LearningModelBindModeFilter Include(LearningModelBindMode mode);
    LearningModelBindModeFilter Clear();
  }

  //! \class LearningModelBatchingStrategyFilter
  //! \brief 
  [marshaling_behavior(agile)]
  [dualapipartition(1)]
  runtimeclass LearningModelBatchingStrategyFilter : Windows.Foundation.Collections.IVectorView<UInt32> {
    UInt32 BatchSizeStart { get; set; };
    UInt32 BatchSizeStride { get; set; };
    UInt32 BatchSizeTotal { get; set; };
  }

  //! \class LearningModelBindingStrategyFilter
  //! \brief 
  [marshaling_behavior(agile)]
  [dualapipartition(1)]
  runtimeclass LearningModelPhaseFilter : Windows.Foundation.Collections.IVectorView<LearningModelPhase> {
    LearningModelPhaseFilter IncludeAll();
    LearningModelPhaseFilter Include(LearningModelPhase phase);
    LearningModelPhaseFilter Clear();
  }

  //! \class LearningModelBindingStrategyFilter
  //! \brief 
  [marshaling_behavior(agile)]
  [dualapipartition(1)]
  runtimeclass LearningModelDeviceFilter : Windows.Foundation.Collections.IVectorView<ROOT_NS.AI.MachineLearning.LearningModelDeviceKind> {
    LearningModelDeviceFilter IncludeAll();
    LearningModelDeviceFilter Include(ROOT_NS.AI.MachineLearning.LearningModelDeviceKind kind);
    LearningModelDeviceFilter Clear();
  }

  //! \class LearningModelEnumerateInferenceStrategiesOptions
  //! \brief 
  [threading(both)]
  [marshaling_behavior(agile)]
  [dualapipartition(1)]
  runtimeclass LearningModelEnumerateInferenceStrategiesOptions {
    LearningModelEnumerateInferenceStrategiesOptions();

    //! The OverrideNamedDimension method will allow the model compiler to use constant batch size performance optimizations when setting up the LearningModelSession.
    //! The caller can specify the size of the dimension for a given named dimension.
    //! dimension = 0 indicates that the dimension present in the model should be honored.
    //! dimension > 0 indicates the size of the dimension that will be used to override the model "name" dimension and optimize evaluations.
    void OverrideNamedDimension(String name, UInt32 dimension);

    LearningModelOptimizationMode OptimizationMode { get; set; };
    LearningModelPhaseFilter PhaseFilter { get; };
    LearningModelBindingStrategyFilter InputStrategyFilter { get; };
    LearningModelBindingStrategyFilter OutputStrategyFilter { get; };
    LearningModelReadModeFilter OutputReadModeFilter { get; };
    LearningModelBindModeFilter BindModeFilter { get; };
    LearningModelBatchingStrategyFilter BatchingStrategyFilter { get; };
    LearningModelDeviceFilter DeviceFilter { get; };
  }

  //! \class LearningModelInferenceStrategy
  //! \brief 
  [marshaling_behavior(agile)]
  [dualapipartition(1)]
  runtimeclass LearningModelInferenceStrategy
  {
    ROOT_NS.AI.MachineLearning.LearningModelDeviceKind DeviceKind { get; };
    LearningModelBindingStrategy InputStrategy { get; };
    LearningModelBindingStrategy OutputStrategy { get; };
    LearningModelReadMode OutputReadMode { get; };
    LearningModelBindMode OutputBindMode { get; };
    UInt32 BatchSize { get; };
    Single Metric { get; };
  }

  struct EnumerateInferenceStrategiesProgress
  {
      UInt64 StrategiesEvaluated;
      UInt64 TotalNumberOfStrategies;
  }; 

  //! \class LearningModelInferenceStrategyEnumerator
  //! \brief 
  [threading(both)]
  [marshaling_behavior(agile)]
  [dualapipartition(1)]
  runtimeclass LearningModelInferenceStrategyEnumerator {
    static Windows.Foundation.Collections.IVectorView<LearningModelInferenceStrategy> EnumerateInferenceStrategies(
      String path,
      LearningModelEnumerateInferenceStrategiesOptions options);

    [remote_async]
    static Windows.Foundation.IAsyncOperationWithProgress< Windows.Foundation.Collections.IVectorView<LearningModelInferenceStrategy>, EnumerateInferenceStrategiesProgress > EnumerateInferenceStrategiesAsync(
      String path,
      LearningModelEnumerateInferenceStrategiesOptions options);
  }

  //! \class LearningModelJoinOptions
  //! \brief This class defines Join Options to be used with the JoinModels method
  [dualapipartition(1)]
  runtimeclass LearningModelJoinOptions
  {
      // default constructor
      LearningModelJoinOptions();

      //! The PromoteUnlinkedOutputsToFusedOutputs option allows callers to toggle whether unlinked outputs of the first model,
      //! remain as outputs in the fused model.
      //! The default value for PromoteUnlinkedOutputsToFusedOutputs is true.
      Boolean PromoteUnlinkedOutputsToFusedOutputs{ get; set; };

      //! The CloseModelOnJoin option allows callers to close the second model when the JoinModels method is made.
      //! By enabling this, the engine can reuse the second models protobuf memory rather than copy it.
      //! The default value for CloseModelOnJoin is false.
      Boolean CloseModelOnJoin { get; set; };

      //! The JoinedNodePrefix property specifies whether the nodes of the second model should have a specific prefixed in the joined model.
      //! Node names must be unique or empty. By enabling this, the engine can specifiy the prefix, or eliminate it entirely in cases
      //! where the model is known to contain no duplicate node names.
      //! The default value for CloseModelOnJoin is a new random GUID.
      String JoinedNodePrefix { get; set; };

      //! The Link method joins outputs from the first model to inputs of the second model.
      void Link(String firstModelOutput, String secondModelInput);
  }

  [marshaling_behavior(agile)]
  [dualapipartition(1)]
  runtimeclass LearningModelExperimental {
    LearningModelExperimental(ROOT_NS.AI.MachineLearning.LearningModel model);

    //! The Save method serializes the model as an ONNX model to a specified path.
    void Save(String file_name);

    //! The JoinModel fuses two models by linking  outputs from the first model, to inupts of the second. 
    ROOT_NS.AI.MachineLearning.LearningModel JoinModel(ROOT_NS.AI.MachineLearning.LearningModel other, LearningModelJoinOptions options);
  }

}  // namespace Microsoft.AI.MachineLearning.Experimental
